<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>THIS SIDE OF HISTORY | T-SHIRT ART PRINT</title>
    
    <!-- FONTS -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@900&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- TAILWIND -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- THREE.JS & GSAP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <style>
        /* CORE RESET */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; 
            background-color: #000000;
            color: #FFFFFF;
            font-family: 'Space Mono', monospace;
            touch-action: none; /* Prevents native swipe/scroll to ensure smooth custom swipe navigation */
        }

        /* ART OVERLAY - FLOAT LAYER */
        #art-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            height: 100vh; /* Scales to fit vertically */
            width: auto;
            max-width: 100vw; /* Prevents horizontal overflow on narrow screens */
            object-fit: contain;
            background-color: #000000; /* Black background behind the image */
            opacity: 0.35; /* Increased slightly for visibility on dark */
            z-index: 45; 
            pointer-events: none; 
            mix-blend-mode: screen; /* Changed to screen so it shows on a black background */
        }

        /* --- CCTV / KODACHROME FX (DARK MODE) --- */
        #fx-container {
            position: fixed;
            inset: 0;
            z-index: 25; 
            pointer-events: none;
            overflow: hidden;
        }

        .grain-overlay {
            position: absolute;
            top: -100%;
            left: -100%;
            width: 300%;
            height: 300%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='1'/%3E%3C/svg%3E");
            opacity: 0.08;
            animation: grain-dance 0.4s steps(3) infinite;
            mix-blend-mode: screen;
        }

        .scanlines {
            position: absolute;
            inset: 0;
            background: linear-gradient(
                to bottom,
                rgba(0,0,0,0),
                rgba(0,0,0,0) 50%,
                rgba(255,255,255,0.03) 50%,
                rgba(255,255,255,0.03)
            );
            background-size: 100% 4px;
            animation: scanline-scroll 10s linear infinite;
        }

        .color-grade {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at center, rgba(0,0,0,0) 40%, rgba(0,0,0,0.4) 90%, rgba(0,0,0,0.8) 100%);
            box-shadow: inset 0 0 150px rgba(0, 0, 0, 0.9);
        }

        .screen-shift {
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, rgba(255,0,0,0.03), rgba(0,255,0,0.03), rgba(0,0,255,0.03));
            background-size: 3px 3px;
            mix-blend-mode: screen;
            opacity: 0.3;
        }

        @keyframes grain-dance {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-5%, -10%); }
            20% { transform: translate(-15%, 5%); }
            30% { transform: translate(7%, -25%); }
            40% { transform: translate(-5%, 25%); }
            50% { transform: translate(-15%, 10%); }
            60% { transform: translate(15%, 0%); }
            70% { transform: translate(0%, 15%); }
            80% { transform: translate(3%, 35%); }
            90% { transform: translate(-10%, 10%); }
        }

        @keyframes scanline-scroll {
            0% { background-position: 0% 0%; }
            100% { background-position: 0% 100%; }
        }

        #gl {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            outline: none;
            filter: contrast(1.1) brightness(1.1);
        }

        #ui-layer {
            position: fixed;
            inset: 0;
            z-index: 30;
            pointer-events: none;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .pointer-auto { pointer-events: auto; }

        #loader {
            position: fixed;
            inset: 0;
            background: #000000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease-out;
        }
        
        .tag-container {
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .tag-hidden {
            transform: translate(10%, 85%) rotate(-5deg);
        }
        .tag-visible {
            transform: translate(0, 0) rotate(0deg);
        }
    </style>
</head>
<body>

    <!-- FLOATING ART OVERLAY -->
    <img id="art-overlay" src="IMG_3552.jpeg" onerror="this.style.display='none'">

    <!-- VISUAL FX LAYERS -->
    <div id="fx-container">
        <div class="grain-overlay"></div>
        <div class="scanlines"></div>
        <div class="color-grade"></div>
        <div class="screen-shift"></div>
    </div>

    <canvas id="gl"></canvas>
    
    <!-- LOADER -->
    <div id="loader">
        <div class="text-4xl font-black tracking-tighter mb-2">THIS_SIDE_OF_HISTORY</div>
        <div class="w-16 h-1 bg-white animate-pulse"></div>
        <div class="mt-4 font-mono text-xs opacity-50">ENTERING SHOP...</div>
    </div>

    <!-- UI OVERLAY -->
    <div id="ui-layer">
        
        <!-- HEADER -->
        <header class="flex justify-between items-start w-full pointer-auto">
            <div>
                <h1 class="text-xl font-black tracking-tighter uppercase leading-none font-inter">This Side<br>Of History</h1>
                <p class="text-[10px] font-mono mt-2 bg-white text-black inline-block px-1 font-bold">ART BY ANNABEL DAOU</p>
            </div>
            
            <div class="text-right hidden md:block">
                <p class="text-[10px] uppercase tracking-widest opacity-60">SOHO POP-UP // NYC</p>
                <p class="text-[10px] uppercase tracking-widest opacity-60">40.7128° N, 74.0060° W</p>
                <p class="text-[9px] uppercase tracking-widest opacity-40 mt-1" id="time-display">00:00:00</p>
            </div>
        </header>

        <!-- CENTER HINT -->
        <div class="absolute top-1/2 left-4 md:left-8 -translate-y-1/2 w-32 pointer-events-none opacity-50 hidden md:block">
            <p class="text-[9px] leading-relaxed">
                "The mesh is a trap and a safety net."
            </p>
            <div class="h-[1px] w-8 bg-white mt-4"></div>
        </div>

        <!-- FOOTER AREA -->
        <footer class="flex justify-between items-end w-full pointer-auto relative h-20">
            <div class="flex flex-col gap-1 absolute bottom-0 left-0">
                <div class="text-[10px] uppercase font-bold opacity-60">Drag or Scroll to Explore</div>
                <div class="w-full h-[1px] bg-white/30"></div>
                <div class="text-[10px] uppercase font-bold">Limited Edition: 042/100</div>
            </div>
        </footer>
    </div>

    <!-- FLOATING INTERACTIVE TAG -->
    <div id="tag-wrapper" class="fixed bottom-8 right-8 z-40 pointer-auto tag-container tag-hidden cursor-pointer group" onclick="toggleTag()">
        
        <div class="absolute -top-12 right-0 bg-white text-black px-4 py-2 font-bold text-xs uppercase tracking-widest shadow-lg group-hover:-translate-y-1 transition-transform">
            Admission $150
        </div>

        <div class="bg-white text-black w-56 shadow-2xl relative border border-gray-200 p-6 flex flex-col items-center text-center transform origin-bottom-right">
            
            <button class="absolute top-2 right-2 text-gray-400 hover:text-black" onclick="event.stopPropagation(); toggleTag()">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
            </button>

            <div class="absolute -top-3 left-1/2 -translate-x-1/2 w-4 h-4 bg-[#FAFAFA] rounded-full border border-gray-300 shadow-inner"></div>

            <div class="text-xs font-bold uppercase tracking-widest border-b border-black pb-1 mb-4 w-full mt-2">Ticket</div>
            
            <div class="flex justify-between w-full items-baseline mb-2">
                <span class="font-black text-3xl">$150</span>
                <span class="text-[10px] opacity-50">USD</span>
            </div>

            <p class="text-[10px] leading-tight opacity-60 mb-4 text-left w-full">
                > 100% Cotton<br>
                > Right side of history<br>
                > Screen Printed design on shirt is photo of Annabel Daou's art (pictured still in foreground of this page); 3d render is modeled after original art design for site only<br>
                > Sizes: S,M,L
            </p>

            <button class="bg-black text-white w-full py-3 text-xs font-bold uppercase hover:bg-red-600 transition-colors" onclick="event.stopPropagation(); window.open('https://buy.stripe.com/00wbIU1ot8Zh7T18yadwc06', '_blank')">
                Acquire
            </button>
        </div>
    </div>

    <script>
        setInterval(() => {
            const now = new Date();
            document.getElementById('time-display').innerText = now.toLocaleTimeString('en-US', { hour12: false });
        }, 1000);

        const config = {
            bgColor: 0x000000,
            wireColor: '#111111', 
            shirtColor: 0xFFFFFF,
            density: 28,
            lineThickness: 4, 
        };

        let scene, camera, renderer, shirtMesh, textMesh;
        
        // Custom Interaction & Scrolling Variables
        let scrollPos = 0;
        let targetScrollPos = 0;
        const maxScroll = 5000;
        let currentScroll = 0;
        
        let mouse = new THREE.Vector2();
        let isTagOpen = false;

        function toggleTag() {
            isTagOpen = !isTagOpen;
            const el = document.getElementById('tag-wrapper');
            if(isTagOpen) {
                el.classList.remove('tag-hidden');
                el.classList.add('tag-visible');
            } else {
                el.classList.add('tag-hidden');
                el.classList.remove('tag-visible');
            }
        }

        function createShirtTextures() {
            const size = 2048;
            const wW = size * 0.40; 
            const wX = (size - wW) / 2;
            const wY = size * 0.18; 
            const wH = size * 0.62; 
            const step = size / config.density;

            const wireCanvas = document.createElement('canvas');
            wireCanvas.width = size; wireCanvas.height = size;
            const wCtx = wireCanvas.getContext('2d');
            wCtx.strokeStyle = '#FFFFFF'; 
            wCtx.lineWidth = config.lineThickness;
            wCtx.lineCap = 'butt'; wCtx.lineJoin = 'miter';
            
            wCtx.beginPath(); wCtx.rect(wX, wY, wW, wH); wCtx.clip();
            drawStructuredFence(wCtx, size, step);
            
            const aCanvas = document.createElement('canvas');
            aCanvas.width = size; aCanvas.height = size;
            const aCtx = aCanvas.getContext('2d');
            aCtx.fillStyle = '#FFFFFF'; aCtx.fillRect(0,0,size,size);
            aCtx.fillStyle = '#000000'; aCtx.fillRect(wX, wY, wW, wH);
            aCtx.drawImage(wireCanvas, 0, 0);
            const alphaMap = new THREE.CanvasTexture(aCanvas);
            alphaMap.anisotropy = 16;
            
            const cCanvas = document.createElement('canvas');
            cCanvas.width = size; cCanvas.height = size;
            const cCtx = cCanvas.getContext('2d');
            cCtx.fillStyle = '#FFFFFF'; cCtx.fillRect(0,0,size,size);
            
            const blackWireCanvas = document.createElement('canvas');
            blackWireCanvas.width = size; blackWireCanvas.height = size;
            const bCtx = blackWireCanvas.getContext('2d');
            bCtx.fillStyle = config.wireColor; bCtx.fillRect(0,0,size,size);
            bCtx.globalCompositeOperation = 'destination-in';
            bCtx.drawImage(wireCanvas, 0, 0);
            
            cCtx.drawImage(blackWireCanvas, 0, 0);
            const colorMap = new THREE.CanvasTexture(cCanvas);
            colorMap.anisotropy = 16;
            
            return { alphaMap, colorMap };
        }

        function drawStructuredFence(ctx, size, step) {
            const isBroken = () => Math.random() < 0.05; 
            const isBent = () => Math.random() < 0.02;   
            const aspect = 2.0; 

            for (let offset = -size * aspect; offset < size; offset += step) {
                ctx.beginPath();
                for (let x = 0; x < size; x += step) {
                    const x1 = x;
                    const y1 = aspect * x + offset;
                    const x2 = x + step;
                    const y2 = aspect * (x + step) + offset;
                    if ((y1 < -100 && y2 < -100) || (y1 > size + 100 && y2 > size + 100)) continue;
                    if (!isBroken()) {
                        if (isBent()) {
                            const midX = (x1 + x2) / 2 + (Math.random() - 0.5) * 8;
                            const midY = (y1 + y2) / 2 + (Math.random() - 0.5) * 8;
                            ctx.moveTo(x1, y1); ctx.lineTo(midX, midY); ctx.lineTo(x2, y2);
                        } else {
                            ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
                        }
                    }
                }
                ctx.stroke();
            }

            for (let offset = -size; offset < size + (size * aspect); offset += step) {
                ctx.beginPath();
                for (let x = 0; x < size; x += step) {
                    const x1 = x;
                    const y1 = -aspect * x + offset;
                    const x2 = x + step;
                    const y2 = -aspect * (x + step) + offset;
                    if ((y1 < -100 && y2 < -100) || (y1 > size + 100 && y2 > size + 100)) continue;
                    if (!isBroken()) {
                        if (isBent()) {
                            const midX = (x1 + x2) / 2 + (Math.random() - 0.5) * 8;
                            const midY = (y1 + y2) / 2 + (Math.random() - 0.5) * 8;
                            ctx.moveTo(x1, y1); ctx.lineTo(midX, midY); ctx.lineTo(x2, y2);
                        } else {
                            ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
                        }
                    }
                }
                ctx.stroke();
            }
        }

        function createTextTexture() {
            const size = 1024;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,size,size);
            ctx.fillStyle = config.shirtColor; 
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.font = '900 110px "Inter", "Arial Black", sans-serif';
            const cx = size/2; const cy = size/2; const lh = 120; 
            ctx.fillText("THIS", cx, cy - lh * 1.5);
            ctx.fillText("SIDE", cx, cy - lh * 0.5);
            ctx.fillText("OF", cx, cy + lh * 0.5);
            ctx.fillText("HISTORY", cx, cy + lh * 1.5);
            return new THREE.CanvasTexture(canvas);
        }

        function createShirtGeometry() {
            const shape = new THREE.Shape();
            const w = 1.7; const h = 2.5; const sLen = 1.2;
            shape.moveTo(0, -h);
            shape.splineThru([new THREE.Vector2(w * 0.6, -h - 0.2), new THREE.Vector2(w, -h)]);
            shape.bezierCurveTo(w - 0.1, -1, w - 0.2, 0.5, w - 0.1, 0.9);
            shape.bezierCurveTo(w + 0.4, 0.7, w + sLen - 0.1, 0.4, w + sLen, 0.4);
            shape.bezierCurveTo(w + sLen + 0.2, 0.4, w + sLen + 0.2, 1.0, w + sLen, 1.0);
            shape.lineTo(1.8, 1.9);
            shape.bezierCurveTo(1.2, 1.9, 0.5, 1.5, 0, 1.5);
            shape.bezierCurveTo(-0.5, 1.5, -1.2, 1.9, -1.8, 1.9);
            shape.lineTo(-w - sLen, 1.0);
            shape.bezierCurveTo(-w - sLen - 0.2, 1.0, -w - sLen - 0.2, 0.4, -w - sLen, 0.4);
            shape.bezierCurveTo(-w - sLen + 0.1, 0.4, -w - 0.4, 0.7, -w + 0.1, 0.9);
            shape.bezierCurveTo(-w + 0.2, 0.5, -w + 0.1, -1, -w, -h);
            shape.splineThru([new THREE.Vector2(-w * 0.6, -h - 0.2), new THREE.Vector2(0, -h)]);

            const extrudeSettings = {
                steps: 2, depth: 0.6, bevelEnabled: true,
                bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 12, curveSegments: 20
            };
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.center();
            geometry.computeBoundingBox();
            const min = geometry.boundingBox.min; const max = geometry.boundingBox.max;
            const rangeX = max.x - min.x; const rangeY = max.y - min.y;
            const pos = geometry.attributes.position; const uv = geometry.attributes.uv;
            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i); const y = pos.getY(i);
                uv.setXY(i, (x - min.x) / rangeX, (y - min.y) / rangeY);
            }
            return geometry;
        }

        // Handle updating target scroll fraction for timeline progression
        function updateTargetScroll() {
            targetScrollPos = currentScroll / maxScroll;
            targetScrollPos = Math.max(0, Math.min(1, targetScrollPos));
        }

        // Map mouse wheel to our custom timeline
        window.addEventListener('wheel', (e) => {
            currentScroll += e.deltaY;
            currentScroll = Math.max(0, Math.min(maxScroll, currentScroll));
            updateTargetScroll();
        }, { passive: true });

        // Map pointer interactions (touch swipe & mouse drag)
        let isDragging = false;
        let lastPos = { x: 0, y: 0 };

        window.addEventListener('pointerdown', (e) => {
            // Ignore if clicking on interactive UI elements (like buttons/tags)
            if (e.target.closest('.pointer-auto')) return;
            isDragging = true;
            lastPos = { x: e.clientX, y: e.clientY };
        });

        window.addEventListener('pointermove', (e) => {
            // Always update mouse position for the tilt/rotation effect
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            if (!isDragging) return;
            
            const deltaX = lastPos.x - e.clientX;
            const deltaY = lastPos.y - e.clientY;
            
            // Allow horizontal OR vertical swiping to move the animation timeline
            const movementDelta = (Math.abs(deltaX) > Math.abs(deltaY)) ? deltaX : deltaY;
            
            currentScroll += movementDelta * 3.5; // Multiplier for swipe sensitivity
            currentScroll = Math.max(0, Math.min(maxScroll, currentScroll));
            updateTargetScroll();
            
            lastPos = { x: e.clientX, y: e.clientY };
        });

        window.addEventListener('pointerup', () => isDragging = false);
        window.addEventListener('pointercancel', () => isDragging = false);

        function init() {
            const canvas = document.getElementById('gl');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(config.bgColor);
            scene.fog = new THREE.Fog(config.bgColor, 10, 30);
            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 10; 
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            scene.add(new THREE.AmbientLight(0xffffff, 0.9));
            const spot = new THREE.SpotLight(0xffffff, 0.8);
            spot.position.set(5, 10, 10); spot.castShadow = true;
            spot.shadow.mapSize.width = 2048; spot.shadow.mapSize.height = 2048;
            scene.add(spot);
            
            const { alphaMap, colorMap } = createShirtTextures();
            const textTex = createTextTexture();

            const material = new THREE.MeshStandardMaterial({
                map: colorMap, alphaMap: alphaMap, alphaTest: 0.25, 
                side: THREE.FrontSide, 
                roughness: 0.6, metalness: 0.1, transparent: false 
            });
            material.customDepthMaterial = new THREE.MeshDepthMaterial({
                depthPacking: THREE.RGBADepthPacking, map: alphaMap, alphaTest: 0.25
            });

            const geo = createShirtGeometry();
            shirtMesh = new THREE.Mesh(geo, material);
            shirtMesh.castShadow = true; shirtMesh.receiveShadow = true;
            scene.add(shirtMesh);

            const textGeo = new THREE.PlaneGeometry(2.3, 3.3); 
            const textMat = new THREE.MeshBasicMaterial({
                map: textTex, transparent: true, opacity: 0.95, color: 0x000000, side: THREE.FrontSide
            });
            textMesh = new THREE.Mesh(textGeo, textMat);
            textMesh.position.z = -0.28; textMesh.position.y = 0.1;
            shirtMesh.add(textMesh);

            const bgGeo = new THREE.PlaneGeometry(60, 60);
            const bgMat = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF, alphaMap: alphaMap, alphaTest: 0.1, transparent: true, opacity: 0.05, side: THREE.DoubleSide
            });
            const bgMesh = new THREE.Mesh(bgGeo, bgMat);
            bgMesh.position.z = -5; bgMesh.scale.set(2,2,2); 
            scene.add(bgMesh);

            window.addEventListener('resize', onResize);
            
            setTimeout(() => {
                const l = document.getElementById('loader');
                l.style.opacity = '0';
                setTimeout(() => l.style.display = 'none', 500);
            }, 800);

            setTimeout(() => {
                const newTex = createTextTexture();
                textMesh.material.map = newTex;
                textMesh.material.needsUpdate = true;
            }, 500);

            animate();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            scrollPos += (targetScrollPos - scrollPos) * 0.05;
            const time = Date.now() * 0.001;
            
            if (shirtMesh) {
                shirtMesh.position.z = -scrollPos * 2;
                shirtMesh.position.y = Math.sin(time * 0.5) * 0.1 + (scrollPos * 0.5);
                const spin = scrollPos * Math.PI * 4;
                const jitter = (Math.random() - 0.5) * 0.002;
                shirtMesh.rotation.x = (mouse.y * 0.2) + Math.sin(time) * 0.05 + jitter;
                shirtMesh.rotation.y = (mouse.x * 0.2) + spin + jitter;
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>


